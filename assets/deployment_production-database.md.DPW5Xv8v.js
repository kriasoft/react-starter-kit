import{_ as a,c as i,o as n,a6 as t}from"./chunks/framework.C7CfgHXo.js";const g=JSON.parse('{"title":"Production Database","description":"","frontmatter":{},"headers":[],"relativePath":"deployment/production-database.md","filePath":"deployment/production-database.md","lastUpdated":0}'),r={name:"deployment/production-database.md"};function s(o,e,d,l,p,c){return n(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="production-database" tabindex="-1">Production Database <a class="header-anchor" href="#production-database" aria-label="Permalink to “Production Database”">​</a></h1><p>The production database runs on <a href="https://neon.tech/" target="_blank" rel="noreferrer">Neon PostgreSQL</a> with <a href="https://developers.cloudflare.com/hyperdrive/" target="_blank" rel="noreferrer">Cloudflare Hyperdrive</a> providing connection pooling at the edge.</p><h2 id="neon-setup" tabindex="-1">Neon Setup <a class="header-anchor" href="#neon-setup" aria-label="Permalink to “Neon Setup”">​</a></h2><ol><li>Create a Neon project at <a href="https://console.neon.tech/" target="_blank" rel="noreferrer">console.neon.tech</a> (or via <a href="https://get.neon.com/HD157BR" target="_blank" rel="noreferrer">referral</a>)</li><li>Create separate databases for staging and production (or use Neon branching)</li><li>Copy the connection strings — you&#39;ll need them for Hyperdrive and migrations</li></ol><p>The connection string format: <code>postgresql://user:pass@host/dbname?sslmode=require</code></p><h2 id="hyperdrive-configuration" tabindex="-1">Hyperdrive Configuration <a class="header-anchor" href="#hyperdrive-configuration" aria-label="Permalink to “Hyperdrive Configuration”">​</a></h2><p>Hyperdrive is provisioned via Terraform. The module in <code>infra/modules/cloudflare/hyperdrive/</code> parses the Neon connection string and creates a Hyperdrive config with connection pooling:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Provision Hyperdrive for staging</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bun</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> infra:staging:edge:apply</span></span></code></pre></div><p>This creates two Hyperdrive bindings per environment:</p><table tabindex="0"><thead><tr><th>Binding</th><th>Caching</th><th>Use for</th></tr></thead><tbody><tr><td><code>HYPERDRIVE_CACHED</code></td><td>Disabled by default</td><td>Read-heavy queries (enable in Terraform if needed)</td></tr><tr><td><code>HYPERDRIVE_DIRECT</code></td><td>None</td><td>Writes, real-time reads</td></tr></tbody></table><p>After Terraform applies, copy the Hyperdrive IDs from the output into <code>apps/api/wrangler.jsonc</code> for each environment.</p><p>See <a href="/database/#connection-architecture">Database: Connection Architecture</a> for how these bindings are used in application code.</p><h2 id="running-migrations" tabindex="-1">Running Migrations <a class="header-anchor" href="#running-migrations" aria-label="Permalink to “Running Migrations”">​</a></h2><p>Migrations run directly against Neon (not through Hyperdrive). The <code>db/</code> workspace provides environment-specific commands:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Staging</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bun</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> db:migrate:staging</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Production</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bun</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> db:migrate:prod</span></span></code></pre></div><p>These commands read connection strings from <code>.env.staging.local</code> and <code>.env.prod.local</code> respectively. See <a href="/database/migrations">Database: Migrations</a> for the full workflow.</p><div class="warning custom-block"><p class="custom-block-title custom-block-title-default">WARNING</p><p>Always review generated migration SQL before running against production. Use <code>bun db:generate</code> to preview changes, then inspect the files in <code>db/migrations/</code> before applying.</p></div><h2 id="database-performance" tabindex="-1">Database Performance <a class="header-anchor" href="#database-performance" aria-label="Permalink to “Database Performance”">​</a></h2><ul><li><strong>Connection pooling</strong> — Hyperdrive maintains a pool at the edge, reducing cold-start latency</li><li><strong>Indexes</strong> — add indexes for frequently queried columns, especially foreign keys used in multi-tenant filters</li><li><strong>Monitor slow queries</strong> — use the Neon dashboard to identify and optimize slow queries</li><li><strong>Compute auto-suspend</strong> — Neon suspends idle compute after inactivity; first request after suspend has higher latency</li></ul>`,19)])])}const u=a(r,[["render",s]]);export{g as __pageData,u as default};
