import{_ as s,c as a,o as i,a6 as t}from"./chunks/framework.C7CfgHXo.js";const k=JSON.parse('{"title":"Database","description":"","frontmatter":{},"headers":[],"relativePath":"database/index.md","filePath":"database/index.md","lastUpdated":0}'),n={name:"database/index.md"};function r(d,e,h,l,o,p){return i(),a("div",null,[...e[0]||(e[0]=[t(`<h1 id="database" tabindex="-1">Database <a class="header-anchor" href="#database" aria-label="Permalink to “Database”">​</a></h1><p>The <code>db/</code> workspace manages the data layer with <a href="https://orm.drizzle.team/" target="_blank" rel="noreferrer">Drizzle ORM</a> and <a href="https://neon.tech/" target="_blank" rel="noreferrer">Neon PostgreSQL</a>. In production, <a href="https://developers.cloudflare.com/hyperdrive/" target="_blank" rel="noreferrer">Cloudflare Hyperdrive</a> pools and caches connections at the edge.</p><h2 id="workspace-structure" tabindex="-1">Workspace Structure <a class="header-anchor" href="#workspace-structure" aria-label="Permalink to “Workspace Structure”">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>db/</span></span>
<span class="line"><span>├── schema/             # Table definitions and relations</span></span>
<span class="line"><span>├── migrations/         # Auto-generated SQL migrations</span></span>
<span class="line"><span>├── seeds/              # Seed data scripts</span></span>
<span class="line"><span>├── scripts/            # Utilities (seed runner, export, introspect)</span></span>
<span class="line"><span>├── drizzle.config.ts   # Drizzle Kit configuration</span></span>
<span class="line"><span>└── index.ts            # Re-exports schema + DatabaseSchema type</span></span></code></pre></div><p>Schema files are organized by domain — one file per entity group (e.g., <code>user.ts</code> contains the user, session, identity, and verification tables). All tables are re-exported from <code>schema/index.ts</code>.</p><h2 id="connection-architecture" tabindex="-1">Connection Architecture <a class="header-anchor" href="#connection-architecture" aria-label="Permalink to “Connection Architecture”">​</a></h2><p>The API worker connects to Neon through Cloudflare Hyperdrive, which provides connection pooling and optional query caching at the edge.</p><p>Two Hyperdrive bindings are available:</p><table tabindex="0"><thead><tr><th>Binding</th><th>Cache</th><th>Use for</th></tr></thead><tbody><tr><td><code>HYPERDRIVE_CACHED</code></td><td>60 s query cache</td><td>Read-heavy queries where slight staleness is acceptable</td></tr><tr><td><code>HYPERDRIVE_DIRECT</code></td><td>None</td><td>Writes, real-time reads, anything requiring fresh data</td></tr></tbody></table><p>Both are exposed in <a href="/api/context">tRPC context</a> as <code>ctx.db</code> (cached) and <code>ctx.dbDirect</code> (direct):</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// apps/api/lib/db.ts (simplified)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createDb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hyperdrive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Hyperdrive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> client</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> postgres</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hyperdrive.connectionString, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    max: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// single connection per Worker isolate</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prepare: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// required for Hyperdrive compatibility</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> drizzle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(client, { schema, casing: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;snake_case&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title custom-block-title-default">INFO</p><p>In development, the API server connects directly via <code>DATABASE_URL</code> without Hyperdrive. The connection setup is transparent — your queries work the same way in both environments.</p></div><h2 id="commands" tabindex="-1">Commands <a class="header-anchor" href="#commands" aria-label="Permalink to “Commands”">​</a></h2><p>Run from the repo root. Append <code>:staging</code> or <code>:prod</code> to target other environments.</p><table tabindex="0"><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>bun db:generate</code></td><td>Generate migration SQL from schema changes</td></tr><tr><td><code>bun db:migrate</code></td><td>Apply pending migrations</td></tr><tr><td><code>bun db:push</code></td><td>Push schema directly (skips migration files)</td></tr><tr><td><code>bun db:studio</code></td><td>Open Drizzle Studio browser UI</td></tr><tr><td><code>bun db:seed</code></td><td>Run seed scripts</td></tr><tr><td><code>bun db:check</code></td><td>Check for drift between schema and migrations</td></tr><tr><td><code>bun db:export</code></td><td>Export database via pg_dump to <code>db/backups/</code></td></tr></tbody></table><h2 id="environment-targeting" tabindex="-1">Environment Targeting <a class="header-anchor" href="#environment-targeting" aria-label="Permalink to “Environment Targeting”">​</a></h2><p>Database scripts select the environment through the <code>ENVIRONMENT</code> variable (falls back to <code>NODE_ENV</code>). Each environment loads env files in priority order:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>.env.{env}.local  →  .env.local  →  .env</span></span></code></pre></div><p>For example, <code>bun db:push:staging</code> loads <code>.env.staging.local</code> first. The <code>DATABASE_URL</code> variable must be a valid <code>postgres://</code> or <code>postgresql://</code> connection string.</p><p>See <a href="/getting-started/environment-variables">Environment Variables</a> for full details.</p><h2 id="importing-schemas" tabindex="-1">Importing Schemas <a class="header-anchor" href="#importing-schemas" aria-label="Permalink to “Importing Schemas”">​</a></h2><p>The <code>@repo/db</code> package exports two entry points:</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> schema </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@repo/db&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// full schema + DatabaseSchema type</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { user, session } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@repo/db/schema&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// individual tables</span></span></code></pre></div>`,23)])])}const g=s(n,[["render",r]]);export{k as __pageData,g as default};
