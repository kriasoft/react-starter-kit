# Core Package

Welcome to the core package, the foundational layer that keeps all our workspaces singing in harmony! This is where we define shared types, utilities, and common interfaces that prevent your codebase from turning into a Tower of Babel situation. Think of it as the diplomatic translator between your API, frontend, edge functions, and database layers.

## Architecture Overview

The core package serves as the central nervous system for cross-workspace communication in our React Starter Kit. It provides:

- **Shared TypeScript definitions** for consistent typing across workspaces
- **Environment type safety** for Cloudflare Workers and other deployment targets
- **Common interfaces** that prevent API drift between frontend and backend
- **Platform abstractions** that make your code deployment-agnostic

### Why a Core Package?

- **DRY principle**: Define types once, use everywhere (no more copy-paste TypeScript hell)
- **Type consistency**: Ensure your API responses match your frontend expectations
- **Platform abstraction**: Write code that works across different deployment environments
- **Refactoring safety**: Change a type definition once and catch all breaking changes
- **Monorepo harmony**: Keep all workspaces speaking the same language

## Project Structure

```
core/
├── types/                  # Shared type definitions
│   ├── index.ts            # Main type exports and common interfaces
│   └── cloudflare-env.d.ts # Auto-generated Cloudflare environment types
├── index.ts                # Package entry point and exports
├── package.json            # Dependencies and build scripts
└── tsconfig.json           # TypeScript configuration
```

## Type Definitions

### Cloudflare Environment Types (`types/index.ts`)

Our core package defines environment-specific types for different deployment targets:

```typescript
export type CloudflareEnv = Cloudflare.Env & {
  // Cloudflare Workers secret bindings
  BETTER_AUTH_SECRET: string;
  GOOGLE_CLIENT_ID: string;
  GOOGLE_CLIENT_SECRET: string;
};

export type CloudflareVariables = {
  session?: Session | null;
};
```

These types ensure that:

- **Environment variables are type-safe** across all Cloudflare Workers
- **Authentication sessions** are properly typed throughout the application
- **Database bindings** (D1) are accessible with full type support
- **Asset bindings** for static file serving are properly configured

### Auto-Generated Types (`types/cloudflare-env.d.ts`)

This file is automatically generated by Wrangler and contains the complete Cloudflare environment interface:

```typescript
declare namespace Cloudflare {
  interface Env {
    ENV: "production";
    db: D1Database;
    ASSETS: Fetcher;
    BETTER_AUTH_SECRET: string;
    GOOGLE_CLIENT_ID: string;
    GOOGLE_CLIENT_SECRET: string;
  }
}
```

**Important:** This file is generated by running:

```bash
bun run wrangler types --include-runtime=false core/types/cloudflare-env.d.ts
```

## Package Exports

Thanks to our carefully crafted package.json exports, you can import core types cleanly from any workspace:

```typescript
// Import all core types
import type { CloudflareEnv, CloudflareVariables } from "@root/core/types";

// Import from main export
import type { CloudflareEnv } from "@root/core";

// Direct type imports (when you know exactly what you need)
import type { CloudflareEnv } from "@root/core/types";
```

## Usage Across Workspaces

### In API Layer (`@root/api`)

The API layer uses core types for consistent context and environment handling:

```typescript
import type { CloudflareEnv } from "@root/core/types";

export type TRPCContext = {
  req: Request;
  db: ReturnType<typeof drizzle>;
  session: Session | null;
  env?: CloudflareEnv; // Type-safe environment access
};
```

### In Edge Functions (`@root/edge`)

Edge functions leverage core types for deployment-specific configurations:

```typescript
import type { CloudflareEnv, CloudflareVariables } from "@root/core/types";

export default {
  async fetch(request: Request, env: CloudflareEnv, ctx: ExecutionContext) {
    // Fully typed environment and context
    const authSecret = env.BETTER_AUTH_SECRET; //  Type-safe
    const db = env.db; //  D1Database type
  },
};
```

### In Frontend (`@root/app`)

While the frontend doesn't directly use Cloudflare types, it benefits from shared API interfaces:

```typescript
// When core expands to include API response types
import type { UserProfile, ApiResponse } from "@root/core/types";

const user: UserProfile = await api.user.me.query();
```

## Development Workflow

### Local Development

```bash
# Build core types
bun --filter core build

# Type checking
bun --filter core typecheck

# Run tests (when we add them)
bun --filter core test

# Watch mode for development
bun --filter core test --watch
```

### Regenerating Cloudflare Types

When you update your `wrangler.jsonc` configuration, regenerate the Cloudflare types:

```bash
# From the project root
bun run wrangler types --include-runtime=false core/types/cloudflare-env.d.ts

# Or from the core directory
wrangler types --include-runtime=false types/cloudflare-env.d.ts
```

### Adding New Shared Types

1. **Identify cross-workspace types**: Look for types that are duplicated across packages

2. **Add to appropriate location**:

   ```typescript
   // core/types/index.ts
   export interface ApiResponse<T = unknown> {
     data: T;
     success: boolean;
     message?: string;
     errors?: Record<string, string[]>;
   }

   export interface UserProfile {
     id: string;
     email: string;
     name: string;
     createdAt: Date;
   }
   ```

3. **Export from main index**:

   ```typescript
   // core/index.ts
   export type { ApiResponse, UserProfile } from "./types/index.js";
   ```

4. **Update consuming packages**:
   ```typescript
   // Replace local type definitions with core imports
   import type { UserProfile } from "@root/core/types";
   ```

## Environment Abstraction

### Multi-Platform Support

The core package is designed to support multiple deployment platforms:

```typescript
// Future: Platform-agnostic environment types
export type PlatformEnv = {
  // Common environment variables across all platforms
  NODE_ENV: "development" | "production" | "test";
  DATABASE_URL: string;
  AUTH_SECRET: string;
};

// Platform-specific extensions
export type VercelEnv = PlatformEnv & {
  VERCEL_URL: string;
  VERCEL_REGION: string;
};

export type CloudflareEnv = PlatformEnv & Cloudflare.Env;
```

### Configuration Management

The core package provides type-safe configuration patterns:

```typescript
export interface AppConfig {
  auth: {
    providers: ("google" | "github" | "email")[];
    sessionDuration: number;
  };
  database: {
    provider: "d1" | "postgres" | "sqlite";
    connectionString?: string;
  };
  features: {
    organizations: boolean;
    billing: boolean;
    analytics: boolean;
  };
}
```

## Best Practices

### Type Organization

1. **Domain-specific types**: Group related types together
2. **Generic utilities**: Create reusable type utilities
3. **Platform abstractions**: Keep platform-specific types separate
4. **Naming conventions**: Use consistent, descriptive names

### Version Management

Since this is a private package, we use `workspace:*` dependencies:

```json
{
  "dependencies": {
    "core": "workspace:*"
  }
}
```

This ensures all workspaces use the same version of core types.

### Breaking Changes

When making breaking changes to core types:

1. **Update all consuming packages** in the same commit
2. **Run type checking** across all workspaces
3. **Update tests** that depend on changed types
4. **Document the changes** in commit messages

## Common Patterns

### API Response Wrapper

```typescript
export type ApiResult<T> =
  | {
      data: T;
      success: true;
    }
  | {
      error: string;
      success: false;
    };

// Usage across API and frontend
const result: ApiResult<UserProfile> = await api.user.me.query();
if (result.success) {
  console.log(result.data); //  TypeScript knows this is UserProfile
} else {
  console.error(result.error); //  TypeScript knows this is string
}
```

### Environment Variables

```typescript
export interface EnvConfig {
  readonly NODE_ENV: "development" | "production" | "test";
  readonly DATABASE_URL: string;
  readonly AUTH_SECRET: string;
}

// Type-safe environment access
export const getEnvConfig = (env: Record<string, unknown>): EnvConfig => {
  return {
    NODE_ENV: env.NODE_ENV as EnvConfig["NODE_ENV"],
    DATABASE_URL: env.DATABASE_URL as string,
    AUTH_SECRET: env.AUTH_SECRET as string,
  };
};
```

## Testing Strategy

### Type Testing

While the core package is primarily types, we can test type correctness:

```typescript
// tests/types.test.ts
import { describe, it, expectTypeOf } from "vitest";
import type { CloudflareEnv, CloudflareVariables } from "../types";

describe("CloudflareEnv", () => {
  it("should have required auth properties", () => {
    expectTypeOf<CloudflareEnv>().toHaveProperty("BETTER_AUTH_SECRET");
    expectTypeOf<CloudflareEnv>().toHaveProperty("GOOGLE_CLIENT_ID");
  });
});
```

### Integration Testing

Test that types work correctly across workspaces:

```typescript
// tests/integration.test.ts
import { describe, it, expect } from "vitest";

describe("Cross-workspace type compatibility", () => {
  it("should allow API context to use CloudflareEnv", () => {
    // Test actual usage patterns
  });
});
```

## Troubleshooting

### Common Issues

**Type not found errors:**

- Ensure you're importing from the correct path
- Check that the core package is built (`bun --filter core build`)
- Verify the type is exported from the main index file

**Outdated Cloudflare types:**

- Regenerate types with `wrangler types`
- Ensure your `wrangler.jsonc` is up to date
- Check that D1 bindings match your configuration

**Circular dependency warnings:**

- Keep core types simple and dependency-free
- Avoid importing runtime code in type definitions
- Use type-only imports when possible

## Future Enhancements

### Planned Features

1. **Runtime validation**: Add Zod schemas alongside TypeScript types
2. **Platform adapters**: Abstract deployment-specific logic
3. **Configuration management**: Type-safe app configuration system
4. **Error boundaries**: Standardized error handling patterns
5. **Event types**: Shared event interfaces for real-time features

### Utility Types

```typescript
// Future utility types
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

export type RequiredKeys<T, K extends keyof T> = T & Required<Pick<T, K>>;

export type ApiEndpoint<TInput, TOutput> = {
  input: TInput;
  output: TOutput;
};
```

## Contributing

When adding new shared types:

1. **Consider the scope**: Is this truly shared across workspaces?
2. **Keep it simple**: Avoid complex dependencies in core types
3. **Document breaking changes**: Update all consumers when changing existing types
4. **Test compatibility**: Ensure types work across all target platforms
5. **Follow conventions**: Match existing naming and organization patterns

Remember: The core package is like the foundation of a house  make it solid, keep it simple, and everyone else can build amazing things on top of it <�

## Resources

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Cloudflare Workers Types](https://developers.cloudflare.com/workers/wrangler/commands/#types)
- [Better Auth Types](https://www.better-auth.com/docs/concepts/session)

---

> _Types are like a good foundation 🏛️ — invisible when done right, catastrophic when done wrong._  
> — 🏗️ Ancient Architecture Proverb
